<html>
  <head>
    <title>Hello World</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
      html, body {
        margin: 0;
        background-color: #000;
      }

      span.fps {
        position:absolute;
        padding:10px;
        color:white;
      }
    </style>
  </head>
  <body>
    <span class="fps" ><span id = "fps_meter"></span> FPS</span>
    <script src="/webpack-dev-server.js"></script>
    <script src="../dist/siick.js"></script>
    <script type="text/javascript">
      const canvas = document.createElement('canvas');
      canvas.style.display = 'block';
      canvas.style.boxSizing = 'border-box';

      canvas.width = window.innerWidth * window.devicePixelRatio;
      canvas.height = window.innerHeight * window.devicePixelRatio;
      canvas.style.width = window.innerWidth;
      canvas.style.height = window.innerHeight;
      document.body.appendChild(canvas);

      const objectsToLoad = [{
        name : 'die',
        obj: 'data/crysponza/sponza.obj',
        mtl: true,
        indicesPerMaterial:true,
        calcTangentsAndBitangents: true
      },
      ];

      const texturesToLoad = {
        'placeholder': 'placeholder.jpg'
      };

      
      //const resourceLoader = new siick.ResourceLoader();
      //materialLoader.load(objectMaterialsToLoad);
      //const loadImagesPromise = resourceLoader.loadImages(texturesToLoad);
      
      const objLoader = new siick.ObjectLoader();
      const loadModelsAndMaterialsPromise = objLoader.loadModelsAndMaterials(objectsToLoad);

      Promise.all([loadModelsAndMaterialsPromise]).then(([objMatData]) => {
        console.log("object and mat data", objMatData);       

        const scene = new siick.Scene();
        //const camera = new siick.PerspectiveCamera(90, window.innerWidth / window.innerHeight, 1.0, 5000.0);
        let scale = 2000;
        const camera = new siick.OrthographicCamera(-scale , scale , -scale  , scale  , scale, -scale );
        //camera.position[2] = 0;
        //camera.position[0] = 0;
        //camera.position[1] = 0;
        const renderer = new siick.Renderer(canvas);
        const geometry = new siick.Cube(0.5, 0.5, 0.5);

        // 1. Create orthographic camera, align viewport with scene
        window.addEventListener('resize', () => {
          renderer.setSize(window.innerWidth, window.innerHeight);        
        });

        const pointLight = new siick.PointLight(
          { color: [1.0, 1.0, 1.0, 1.0], intensity: 1.0 , debug: true}
        );

        const directionalLight = new siick.DirectionalLight(
          { direction: [0.0, -10.0, 0.0, 1.0], intensity: 1.0, debug: true }
        );

        // Set up buffers for mesh
        //const dieMesh = new siick.Mesh(objMatData[0].objectData);
        const objData = objMatData[0];
        for (let i = 0; i < objData.indices.length; ++i) {
          const mesh = new siick.Mesh(objData.objectData, objData.indices[i]); // Set up all buffers
          const material = new siick.Material(objData.materialData.materialsByIndex[i]);
          mesh.setMaterialData(material);
          scene.add(mesh);
        }

        //const material = new siick.Material(objMatData[0].materialData);
        //dieMesh.attachShader(objMatData[0].materialData);
        
        pointLight.position[1] += 260.0;
        // scene.add(dieMesh);
        scene.add(pointLight);
        //scene.add(directionalLight);
  
       // const fl = new siick.FlyControls(camera);
        const fpsMeter = document.getElementById("fps_meter");

        let prev = 0;

        const render = now => {
          let delta = now - prev;
          let fps = Math.round(1000 / delta);
          prev = now;

          fpsMeter.innerHTML = fps;

          // Updates view matrix
          //fl.update(0.1);
         // dieMesh2.rotation[0] += 0.01;
          //dieMesh2.rotation[1] += 0.01;

         // suzanneMesh.rotation[0] += 0.01;
        //  suzanneMesh.rotation[1] += 0.01;
          scene.traverse(camera);
          renderer.render(scene, camera);
          requestAnimationFrame(render);
        }
        render();
      });
    </script>

  </body>
</html>

